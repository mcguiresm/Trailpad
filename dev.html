<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Trailpad - Refactor (Unified State)</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
    
<style>
    @font-face {
        font-family: "Swiss721";
        src: url("fonts/Swiss721BT-Black.ttf") format("truetype"),
             url("fonts/Swiss721BT-Black.woff2") format("woff2"),
             url("fonts/Swiss721BT-Black.woff") format("woff");
        font-weight: bold;
        font-style: normal;
    }

    html, body {
        width: 100%;
        height: 100%;
        margin: 0;
        background: transparent;
        font-family: "Swiss721", Arial, sans-serif;
        text-transform: uppercase;
        user-select: none;
    }

    #app { position: absolute; top: 0px; left: 0px; }

    #stickWrapper {
        width: 230px; height: 230px;
        position: absolute; top: 50px; left: 50px;
        background: transparent;
        background-image: url("images/gate_strive.svg");
        background-size: cover;
        border-radius: 0%;
    }

    #stickCanvas {
        width: 100%; height: 100%;
        display: block;
        background: transparent;        
    }

    .joystickHead {
        position: absolute; left: 50%; top: 50%;
        width: 50px; height: 50px;
        border-radius: 50%;
        outline: 4px solid rgba(255,255,255,0.5);
        outline-offset: -4px;
        box-shadow: 0px 2px 0px 5px rgba(0,0,0,1);
        transform: translate(-50%,-50%) scale(1);
        pointer-events: none;
        display: flex; align-items: center; justify-content: center;
        font-weight: bold; font-size: 24px;
        transition: left 0.01s, top 0.01s, transform 0.1s;
        background: rgba(80,80,80,1); color: #000;
    }

    #directionMarkers {
        position: absolute; top: 0; left: 0;
        width: 100%; height: 100%;
        pointer-events: none;
    }

    .marker {
        position: absolute; width: 8px; height: 8px;
        border-radius: 50%; background: rgba(255,255,255,0.1);
        transform: translate(-50%, -50%);
        transition: all 0.1s;
    }

    .marker.active { background: rgba(255,255,255,1); }

    .btn {
        position: absolute; background: rgba(48,48,48,1);
        width: 90px; height: 90px;
        display: flex; align-items: center; justify-content: center;
        font-size: 40px; transition: 0.05s;
        border-radius: 50%; outline: 4px solid rgba(255,255,255,0.5);
        outline-offset: -4px; box-shadow: 0 2px 0px 6px rgba(0,0,0,1);
        filter: brightness(1);
        overflow: hidden; text-align: center; white-space: nowrap;
        color: #eee; cursor: pointer;
    }

    .btn[data-btn="Up"]		{ top: 50px; left: 120px; background-image: url("images/up.svg"); background-size: contain; background-repeat: no-repeat; background-position: center; }
    .btn[data-btn="Down"]	{ top: 190px; left: 120px; background-image: url("images/down.svg"); background-size: contain; background-repeat: no-repeat; background-position: center; }
    .btn[data-btn="Left"]	{ top: 120px; left: 50px; background-image: url("images/left.svg"); background-size: contain; background-repeat: no-repeat; background-position: center; }
    .btn[data-btn="Right"]	{ top: 120px; left: 190px; background-image: url("images/right.svg"); background-size: contain; background-repeat: no-repeat; background-position: center; }

    .btn[data-btn="A"] { top: 170px; left: 300px; }
    .btn[data-btn="B"] { top: 170px; left: 400px; }
    .btn[data-btn="X"] { top: 70px; left: 300px; }
    .btn[data-btn="Y"] { top: 70px; left: 400px; }

    .btn[data-btn="LB"] { top: 70px; left: 600px; }
    .btn[data-btn="RB"] { top: 70px; left: 500px; }
    .btn[data-btn="LT"] { top: 170px; left: 600px; }
    .btn[data-btn="RT"] { top: 170px; left: 500px; }

    .btn[data-btn="LS"] { top: 250px; left: 360px; width: 70px; height: 70px; }
    .btn[data-btn="RS"] { top: 250px; left: 560px; width: 70px; height: 70px; }
    .btn[data-btn="View"] { top: 20px; left: 300px; width: 90px; height: 40px; border-radius: 30px; font-size: 20px; }
    .btn[data-btn="Menu"] { top: 20px; left: 400px; width: 90px; height: 40px; border-radius: 30px; font-size: 20px; }

    .btn.active { filter: brightness(2.0); transform: scale(1.05); }
    .btn.selected { box-shadow: 0px 2px 0px 6px rgba(255,255,255,1) }
    .stickHighlight.selected { box-shadow: 0px 0px 0px 8px rgba(255,255,255,1) }

    :root {
    --trail-color: #CEEC73; /* default trail color */	
    }	

    /* Palette + toast minimal styles */
    #colorPanel { position: fixed; bottom: 0; left: 0; width: 100%; display: none; background: #000; padding: 10px; z-index: 1000; display: none; flex-wrap: wrap; gap: 4px; }
    #colorPanel .swatch { width:30px; height:30px; border-radius:50%; cursor:pointer; }
    #colorPanel .modeToggle { width:100%; display:flex; justify-content:center; gap:0; margin-bottom:0; }
    #toast { position: fixed; top: 20px; left: 50%; transform: translateX(-50%) scale(0); background: #000; color:#fff; padding:10px; z-index:9999; border-radius: 0; box-shadow: 0 2px 8px rgba(0,0,0,0.5); transition: transform 0.1s ease; font-family: Swiss721, Arial, sans-serif; }
</style>
</head>
<body>
<div id="app">	
    <div id="stickWrapper" class="stickHighlight">
        <div id="directionMarkers">
            <div class="marker" id="marker0"></div>
            <div class="marker" id="marker1"></div>
            <div class="marker" id="marker2"></div>
            <div class="marker" id="marker3"></div>
            <div class="marker" id="marker4"></div>
            <div class="marker" id="marker5"></div>
            <div class="marker" id="marker6"></div>
            <div class="marker" id="marker7"></div>
        </div>
        <canvas id="stickCanvas"></canvas>
        <div class="joystickHead" id="joystickHead"></div>
    </div>
	
    <div class="btn" data-btn="Up"></div>
    <div class="btn" data-btn="Down"></div>
    <div class="btn" data-btn="Left"></div>
    <div class="btn" data-btn="Right"></div>
    <div class="btn" data-btn="A">A</div>
    <div class="btn" data-btn="B">B</div>
    <div class="btn" data-btn="X">X</div>
    <div class="btn" data-btn="Y">Y</div>
    <div class="btn" data-btn="LB">LB</div>
    <div class="btn" data-btn="RB">RB</div>
    <div class="btn" data-btn="LT">LT</div>
    <div class="btn" data-btn="RT">RT</div>
    <div class="btn" data-btn="LS">LS</div>
    <div class="btn" data-btn="RS">RS</div>
    <div class="btn" data-btn="View">View</div>
    <div class="btn" data-btn="Menu">Menu</div>
</div>

<!-- color panel -->
<div id="colorPanel" aria-hidden="true"></div>
<!-- toast -->
<div id="toast" aria-hidden="true"></div>

<script>
/* ===========================
   Unified appState and helpers
   =========================== */

const STORAGE_KEY = "trailpadState_v1"; // bump version if schema changes

const defaultTrailColor = getComputedStyle(document.documentElement).getPropertyValue('--trail-color').trim() || "#CEEC73";

const defaultCfg = {
    deadzone: 0.1,
    trail: 12,
    invertY: false,
    map: {
        A:0, B:1, X:2, Y:3, LB:4, RB:5, LT:6, RT:7,
        View:8, Menu:9, LS:10, RS:11, Up:12, Down:13, Left:14, Right:15
    },
    ignoredForJoystick: ['View','Menu','LS','RS','Up','Down','Left','Right']
};

let cfg = {...defaultCfg};

// elements
const btnEls = {};
document.querySelectorAll('.btn').forEach(el => btnEls[el.dataset.btn] = el);
const stickWrapper = document.getElementById('stickWrapper');
const joystick = document.getElementById('joystickHead');
const canvas = document.getElementById('stickCanvas');
const ctx = canvas.getContext('2d');

const movableElements = {...btnEls, stickWrapper};

/* appState schema:
{
  buttons: {
    A: { top, left, width, height, borderRadius, fontSize, display, backgroundColor, color, label },
    ...
  },
  joystick: { top, left, width, height, borderRadius, display },
  hiddenButtons: [ ... ],
  trailColor: "#xxxxxx",
  profiles: { profile1: {...}, ... }
}
*/

let appState = {
    buttons: {},      // per-button properties
    joystick: {},     // stickWrapper properties
    hiddenButtons: [],// array of names hidden
    trailColor: defaultTrailColor,
    profiles: {}      // profile1..profile4
};

/* Debounced save to reduce churn */
let saveTimer = null;
function scheduleSave() {
    clearTimeout(saveTimer);
    saveTimer = setTimeout(() => {
        try {
            localStorage.setItem(STORAGE_KEY, JSON.stringify(appState));
        } catch (e) {
            console.warn("Failed to save state:", e);
        }
    }, 120); // 120ms debounce
}

function forceSave() {
    clearTimeout(saveTimer);
    try {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(appState));
    } catch (e) {
        console.warn("Failed to save state:", e);
    }
}

/* Load state once */
function loadState() {
    try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (raw) {
            const parsed = JSON.parse(raw);
            // shallow merge to keep default fields if future schema adds them
            appState = Object.assign({}, appState, parsed || {});
        }
    } catch (e) {
        console.warn("Invalid saved state, ignoring.", e);
    }
    applyState();
}

/* Apply stored data to DOM elements */
function applyElementData(el, data) {
    if (!el || !data) return;
    if (data.top) el.style.top = data.top;
    if (data.left) el.style.left = data.left;
    if (data.width) el.style.width = data.width;
    if (data.height) el.style.height = data.height;
    if (data.borderRadius) el.style.borderRadius = data.borderRadius;
    if (data.fontSize) el.style.fontSize = data.fontSize;
    if (data.display) el.style.display = data.display;
    if (data.backgroundColor) el.style.backgroundColor = data.backgroundColor;
    if (data.color) el.style.color = data.color;
    if (data.label !== undefined && el.dataset?.btn) el.textContent = data.label;
}

function applyState() {
    // buttons
    for (const key in btnEls) {
        const el = btnEls[key];
        const data = appState.buttons[key] || {};
        // apply defaults if not set
        // Use computed style fallback if not present in state
        const computed = window.getComputedStyle(el);
        const fallback = {
            top: el.style.top || computed.top || computed.getPropertyValue('top'),
            left: el.style.left || computed.left || computed.getPropertyValue('left'),
            width: el.style.width || computed.width,
            height: el.style.height || computed.height,
            borderRadius: el.style.borderRadius || computed.borderRadius,
            fontSize: el.style.fontSize || computed.fontSize,
            display: el.style.display || computed.display,
            backgroundColor: el.style.backgroundColor || computed.backgroundColor,
            color: el.style.color || computed.color,
            label: (el.textContent || "").trim()
        };
        const merged = Object.assign({}, fallback, data);
        applyElementData(el, merged);
        // also write merged values back to state (so state contains every button after apply)
        appState.buttons[key] = {...merged};
    }

    // joystick/wrapper
    const sw = appState.joystick || {};
    const computedSW = window.getComputedStyle(stickWrapper);
    const swFallback = {
        top: stickWrapper.style.top || computedSW.top,
        left: stickWrapper.style.left || computedSW.left,
        width: stickWrapper.style.width || computedSW.width,
        height: stickWrapper.style.height || computedSW.height,
        borderRadius: stickWrapper.style.borderRadius || computedSW.borderRadius,
        display: stickWrapper.style.display || computedSW.display
    };
    appState.joystick = Object.assign({}, swFallback, sw);
    applyElementData(stickWrapper, appState.joystick);

    // hidden buttons
    if (Array.isArray(appState.hiddenButtons)) {
        appState.hiddenButtons.forEach(btnName => {
            if (btnEls[btnName]) {
                btnEls[btnName].style.display = "none";
                if (!cfg.ignoredForJoystick.includes(btnName)) cfg.ignoredForJoystick.push(btnName);
            }
        });
    } else {
        appState.hiddenButtons = [];
    }

    // trail color
    if (appState.trailColor) {
        document.documentElement.style.setProperty('--trail-color', appState.trailColor);
    }

    resizeCanvas();
    joystick.style.left = (canvas.width / 2) + "px";
    joystick.style.top = (canvas.height / 2) + "px";
    updateMarkers(-1);
    scheduleSave();
}

/* Convenience getters for element state */
function getElementState(key) {
    if (!key) return null;
    if (key === "stickWrapper") return appState.joystick || {};
    if (appState.buttons[key]) return appState.buttons[key];
    return null;
}

/* Update single properties and schedule save */
function updatePosition(key, top, left) {
    if (key === "stickWrapper") {
        appState.joystick.top = top;
        appState.joystick.left = left;
    } else {
        if (!appState.buttons[key]) appState.buttons[key] = {};
        appState.buttons[key].top = top;
        appState.buttons[key].left = left;
    }
    scheduleSave();
}

function updateSize(key, width, height, borderRadius, fontSize) {
    if (key === "stickWrapper") {
        appState.joystick.width = width;
        appState.joystick.height = height;
        if (borderRadius !== undefined) appState.joystick.borderRadius = borderRadius;
    } else {
        if (!appState.buttons[key]) appState.buttons[key] = {};
        if (width !== undefined) appState.buttons[key].width = width;
        if (height !== undefined) appState.buttons[key].height = height;
        if (borderRadius !== undefined) appState.buttons[key].borderRadius = borderRadius;
        if (fontSize !== undefined) appState.buttons[key].fontSize = fontSize;
    }
    scheduleSave();
}

function updateLabel(key, label) {
    if (!appState.buttons[key]) appState.buttons[key] = {};
    appState.buttons[key].label = label;
    scheduleSave();
}

function updateColor(key, background, text) {
    if (key === "trail") {
        appState.trailColor = background;
        document.documentElement.style.setProperty('--trail-color', background);
    } else {
        if (!appState.buttons[key]) appState.buttons[key] = {};
        if (background !== undefined) appState.buttons[key].backgroundColor = background;
        if (text !== undefined) appState.buttons[key].color = text;
    }
    scheduleSave();
}

function setHiddenButton(key, hidden) {
    if (hidden) {
        if (!appState.hiddenButtons.includes(key)) appState.hiddenButtons.push(key);
    } else {
        appState.hiddenButtons = appState.hiddenButtons.filter(k => k !== key);
    }
    // apply immediately
    if (btnEls[key]) btnEls[key].style.display = hidden ? "none" : "flex";
    // maintain joystick ignored list
    if (hidden) {
        if (!cfg.ignoredForJoystick.includes(key)) cfg.ignoredForJoystick.push(key);
    } else {
        cfg.ignoredForJoystick = cfg.ignoredForJoystick.filter(b => b !== key || b === 'View' || b === 'Menu');
    }
    scheduleSave();
}

function setJoystickHidden(hidden) {
    appState.joystick.display = hidden ? "none" : "";
    stickWrapper.style.display = hidden ? "none" : "block";
    scheduleSave();
}

/* Profiles */
const PROFILE_COUNT = 4;
function saveProfile(n) {
    if (n < 1 || n > PROFILE_COUNT) return;
    // collect current live state snapshot
    const snapshot = {
        joystick: Object.assign({}, appState.joystick),
        buttons: {}
    };
    for (const key in btnEls) {
        const el = btnEls[key];
        snapshot.buttons[key] = {
            top: el.style.top || window.getComputedStyle(el).top,
            left: el.style.left || window.getComputedStyle(el).left,
            width: el.style.width || window.getComputedStyle(el).width,
            height: el.style.height || window.getComputedStyle(el).height,
            borderRadius: el.style.borderRadius || window.getComputedStyle(el).borderRadius,
            fontSize: el.style.fontSize || window.getComputedStyle(el).fontSize,
            display: el.style.display || window.getComputedStyle(el).display,
            backgroundColor: el.style.backgroundColor || window.getComputedStyle(el).backgroundColor,
            color: el.style.color || window.getComputedStyle(el).color,
            label: el.textContent || ""
        };
    }
    appState.profiles["profile" + n] = snapshot;
    scheduleSave();
    showToast(`Profile ${n} saved!`);
}

function loadProfile(n) {
    if (n < 1 || n > PROFILE_COUNT) return;
    const snap = appState.profiles["profile" + n];
    if (!snap) {
        showToast(`Profile ${n} not found!`);
        return;
    }
    // apply joystick
    if (snap.joystick) {
        appState.joystick = Object.assign({}, snap.joystick);
        applyElementData(stickWrapper, appState.joystick);
    }
    // apply buttons
    for (const key in snap.buttons) {
        const data = snap.buttons[key];
        if (btnEls[key]) {
            applyElementData(btnEls[key], data);
            // mirror into appState.buttons
            appState.buttons[key] = Object.assign({}, data);
        }
    }
    // update derived UI
    resizeCanvas();
    joystick.style.left = (canvas.width / 2) + "px";
    joystick.style.top = (canvas.height / 2) + "px";
    updateMarkers(-1);
    scheduleSave();
    showToast(`Profile ${n} loaded!`);
}

/* ======================
   Utility & UI helpers
   ====================== */

const toast = document.getElementById('toast');
function bounceToast() {
    toast.style.transition = "transform 0.08s ease";
    toast.style.transform = "translateX(-50%) scale(1.2)";
    setTimeout(() => {
        toast.style.transform = "translateX(-50%) scale(1)";
        toast.style.transition = "transform 0.15s ease";
    }, 80);
}

function showToast(message, duration = 1500) {
    toast.textContent = message;
    if (toast.style.transform.includes("scale(0)")) {
        toast.style.transform = "translateX(-50%) scale(1)";
    } else {
        bounceToast();
    }
    clearTimeout(toast.hideTimeout);
    toast.hideTimeout = setTimeout(() => {
        toast.style.transform = "translateX(-50%) scale(0)";
    }, duration);
}

/* ======================
   Editable labels
   ====================== */

Object.values(btnEls).forEach(btn => {
    if (['Up','Down','Left','Right'].includes(btn.dataset.btn)) return;
    btn.addEventListener("dblclick", () => {
        if (btn.querySelector("input")) return;
        const oldText = btn.textContent.trim();
        btn.textContent = "";
        const input = document.createElement("input");
        input.value = oldText;
        input.style.width = "100%";
        input.style.height = "100%";
        input.style.fontFamily = "inherit";
        input.style.textAlign = "center";
        input.style.textTransform = "uppercase";
        input.style.border = "none";
        input.style.outline = "none";
        input.style.background = "transparent";
        input.style.color = "inherit";
        input.style.padding = "0"; input.style.margin = "0";
        btn.appendChild(input);
        input.focus(); input.select();
        input.addEventListener("blur", save);
        input.addEventListener("keydown", e => {
            if (e.key === "Enter") save();
            else if (e.key === "Escape") {
                btn.textContent = oldText;
                e.stopPropagation();
            }
        });
        function save() {
            const newText = input.value.trim();
            btn.textContent = newText;
            updateLabel(btn.dataset.btn, newText);
        }
    });
});

/* ======================
   Select & move elements
   ====================== */

let selectedElement = null;
Object.values(movableElements).forEach(el => {
    el.addEventListener('mousedown', e => {
        if (selectedElement && selectedElement !== el) selectedElement.classList?.remove("selected");
        selectedElement = el;
        el.classList.add("selected");
        e.stopPropagation();
    });
});
document.addEventListener("mousedown", () => {
    if (selectedElement) selectedElement.classList?.remove("selected");
    selectedElement = null;
});

/* Keyboard Controls (move/resize/fontsize/border radius/hide/reset/unhide) */
document.addEventListener("keydown", e => {
    // ESC: reset (clear saved state)
    if (e.key === "Escape" && e.ctrlKey) {
        // ctrl+esc used to clear all storage and reload (safer than plain esc)
        if (confirm("Reset all saved states and reload?")) {
            localStorage.removeItem(STORAGE_KEY);
            location.reload();
        }
        return;
    }

    // Simple ESC without ctrl does selection clear handled earlier in mousedown
    if (!selectedElement) {
        // F1-F4 load profiles even if nothing selected
        if (!e.ctrlKey && e.key.startsWith("F")) {
            const n = parseInt(e.key.slice(1));
            if (n >= 1 && n <= PROFILE_COUNT) loadProfile(n);
        }
        if (e.ctrlKey && e.key.startsWith("F")) {
            const n = parseInt(e.key.slice(1));
            if (n >= 1 && n <= PROFILE_COUNT) saveProfile(n);
        }
        return;
    }

    // Home: unhide all
    if (e.key === "Home") {
        Object.values(btnEls).forEach(btn => btn.style.display = "flex");
        appState.hiddenButtons = [];
        // restore joystick
        appState.joystick.display = "";
        stickWrapper.style.display = "block";
        cfg.ignoredForJoystick = ['View','Menu', ...cfg.ignoredForJoystick.filter(b => b !== 'View' && b !== 'Menu')];
        scheduleSave();
        e.preventDefault();
        return;
    }

    const style = window.getComputedStyle(selectedElement);
    let top = parseInt(style.top)||0, left = parseInt(style.left)||0;
    let width = parseInt(style.width)||0, height = parseInt(style.height)||0;
    let borderRadius = parseInt(style.borderRadius)||0;
    let fontSize = parseInt(style.fontSize)||36;
    let updated = false;

    function snap10(val){ return Math.round(val/10)*10; }

    if (e.ctrlKey) {
        if (e.key === "[") { fontSize = Math.max(8, fontSize-2); updated=true; e.preventDefault(); }
        if (e.key === "]") { fontSize += 2; updated=true; e.preventDefault(); }
        if (updated) {
            selectedElement.style.fontSize = fontSize + "px";
            // save
            if (selectedElement.dataset?.btn) updateSize(selectedElement.dataset.btn, undefined, undefined, undefined, selectedElement.style.fontSize);
            else if (selectedElement.id === "stickWrapper") updateSize("stickWrapper", undefined, undefined, undefined, selectedElement.style.fontSize);
        }
    } else {
        // Move
        if (!e.shiftKey) {
            if (e.key === "ArrowUp") { top -= 10; updated=true; }
            if (e.key === "ArrowDown") { top += 10; updated=true; }
            if (e.key === "ArrowLeft") { left -= 10; updated=true; }
            if (e.key === "ArrowRight") { left += 10; updated=true; }
        }

        // Resize
        if (e.shiftKey) {
            if (selectedElement.id === "stickWrapper") {
                if (e.key === "ArrowUp" || e.key === "ArrowRight") { 
                    width += 10; height += 10; updated = true; 
                }
                if (e.key === "ArrowDown" || e.key === "ArrowLeft") { 
                    width = Math.max(50, width - 10); 
                    height = Math.max(50, height - 10); 
                    updated = true; 
                }
            } else {
                if (e.key === "ArrowDown") { height = Math.max(10, height - 10); updated=true; }
                if (e.key === "ArrowUp") { height += 10; updated=true; }
                if (e.key === "ArrowLeft") { width = Math.max(10, width - 10); updated=true; }
                if (e.key === "ArrowRight") { width += 10; updated=true; }
            }
        }

        if (e.key === "[") { borderRadius = Math.max(0,borderRadius-10); updated=true; }
        if (e.key === "]") { borderRadius += 10; updated=true; }
    
        // Hide
        if (e.key === "Delete") {
            if (selectedElement?.classList.contains("btn")) {
                selectedElement.style.display = "none";
                const btnName = selectedElement.dataset.btn;
                setHiddenButton(btnName, true);
                e.preventDefault();
                return;
            } else if (selectedElement?.id === "stickWrapper") {
                selectedElement.style.display = "none";
                setJoystickHidden(true);
                e.preventDefault();
                return;
            }
        }
    }

    if (updated) {
        // Apply snapped values
        selectedElement.style.top = snap10(top)+"px";
        selectedElement.style.left = snap10(left)+"px";
        selectedElement.style.width = snap10(width)+"px";
        selectedElement.style.height = snap10(height)+"px";
        selectedElement.style.borderRadius = snap10(borderRadius)+"px";
        
        // save sizes and positions
        if (selectedElement.dataset?.btn) {
            updatePosition(selectedElement.dataset.btn, selectedElement.style.top, selectedElement.style.left);
            updateSize(selectedElement.dataset.btn, selectedElement.style.width, selectedElement.style.height, selectedElement.style.borderRadius, selectedElement.style.fontSize);
        } else if (selectedElement.id==="stickWrapper") {
            updatePosition("stickWrapper", selectedElement.style.top, selectedElement.style.left);
            updateSize("stickWrapper", selectedElement.style.width, selectedElement.style.height, selectedElement.style.borderRadius, selectedElement.style.fontSize);
            // recalc canvas + recenter joystick & markers
            resizeCanvas();
            joystick.style.left = (canvas.width / 2) + "px";
            joystick.style.top = (canvas.height / 2) + "px";
            updateMarkers(-1);
        }
    }
});

/* Move selected element with helpers (used by gamepad) */
function moveSelectedElement(dx, dy) {
    if (!selectedElement) return;
    const style = window.getComputedStyle(selectedElement);
    let top = parseInt(style.top) || 0;
    let left = parseInt(style.left) || 0;
    top += dy; left += dx;
    function snap10(val) { return Math.round(val / 10) * 10; }
    selectedElement.style.top = snap10(top) + "px";
    selectedElement.style.left = snap10(left) + "px";
    if (selectedElement.dataset?.btn) updatePosition(selectedElement.dataset.btn, selectedElement.style.top, selectedElement.style.left);
    else if (selectedElement.id === "stickWrapper") updatePosition("stickWrapper", selectedElement.style.top, selectedElement.style.left);
}

/* D-pad / hold movement via gamepad */
const elementMoveTimers = { up: 0, down: 0, left: 0, right: 0 };
const moveDelay = 100; // ms
const moveStep = 10;

function handleDpadMovement(pad) {
    if (!selectedElement || !pad) return;
    const now = performance.now();
    const directions = [
        { btn: 12, dx: 0, dy: -moveStep, key: "up" },   // Up
        { btn: 13, dx: 0, dy: moveStep, key: "down" },  // Down
        { btn: 14, dx: -moveStep, dy: 0, key: "left" }, // Left
        { btn: 15, dx: moveStep, dy: 0, key: "right" }  // Right
    ];
    directions.forEach(dir => {
        if (pad.buttons[dir.btn]?.pressed && now - elementMoveTimers[dir.key] > moveDelay) {
            moveSelectedElement(dir.dx, dir.dy);
            elementMoveTimers[dir.key] = now;
        }
    });
}

/* ======================
   Gamepad & Button Updates
   ====================== */

let activeGamepadIndex = null;
function detectActiveGamepad() {
    const gamepads = navigator.getGamepads();
    for (let i = 0; i < gamepads.length; i++) {
        const pad = gamepads[i];
        if (!pad) continue;
        const anyButtonPressed = pad.buttons.some(b => b.pressed);
        const anyAxisMoved = pad.axes.some(a => Math.abs(a) > cfg.deadzone);
        if (anyButtonPressed || anyAxisMoved) return i;
    }
    return null;
}

window.addEventListener('gamepadconnected', e => console.log("Connected:", e.gamepad.id, e.gamepad.index));
window.addEventListener('gamepaddisconnected', e => {
    console.log("Disconnected:", e.gamepad.id, e.gamepad.index);
    if (activeGamepadIndex === e.gamepad.index) activeGamepadIndex = null;
});

const lastPressedTimes = {};
function updateButtons(pad){
    if(!pad?.buttons){
        joystick.style.transform='translate(-50%,-50%) scale(1)'; joystick.textContent='';
        Object.values(btnEls).forEach(btn=>btn.classList.remove('active'));
        return;
    }
    for(const key in btnEls){
        const idx=cfg.map[key];
        if(idx===undefined) continue;
        const pressed=!!pad.buttons[idx]?.pressed;
        btnEls[key].classList.toggle('active',pressed);
        lastPressedTimes[key]=pressed?performance.now():lastPressedTimes[key]||0;
    }
    let activeBtn=null,latestTime=-1;
    for(const key in lastPressedTimes){
        if(btnEls[key].classList.contains('active')&&!cfg.ignoredForJoystick.includes(key)
           && lastPressedTimes[key]>latestTime){
            latestTime=lastPressedTimes[key]; activeBtn=key;
        }
    }
    if(activeBtn){
        const btnColor=getComputedStyle(btnEls[activeBtn]).backgroundColor;
        const btnTextColor=getComputedStyle(btnEls[activeBtn]).color;
        joystick.textContent=btnEls[activeBtn].textContent;
        joystick.style.background=btnColor;
        joystick.style.color=btnTextColor;
    } else {
        joystick.style.transform='translate(-50%,-50%) scale(1)';
        joystick.textContent=''; joystick.style.background='rgba(64,64,64,1)';
        joystick.style.color='#fff';
    }
}

/* ======================
   Stick helpers & trail
   ====================== */

function radialDeadzone(x,y,dz){ const mag=Math.hypot(x,y); if(mag<dz) return {x:0,y:0}; const s=(mag-dz)/(1-dz); return {x:x*s/mag,y:y*s/mag}; }
function clampCircle(x,y){ const mag=Math.hypot(x,y); if(mag>1) return {x:x/mag,y:y/mag}; return {x,y}; }
function clampRoundedSquare(x, y, n = 8) {
    const mag = Math.pow(Math.abs(x), n) + Math.pow(Math.abs(y), n);
    if (mag > 1) {
        const scale = Math.pow(mag, -1/n);
        return { x: x * scale, y: y * scale };
    }
    return { x, y };
}

function getStickXY(pad){ if(!pad) return {x:0,y:0}; let {x,y}=radialDeadzone(pad.axes[0]||0,pad.axes[1]||0,cfg.deadzone); const up=pad.buttons[12]?.pressed?1:0; const down=pad.buttons[13]?.pressed?1:0; const left=pad.buttons[14]?.pressed?1:0; const right=pad.buttons[15]?.pressed?1:0; if(up||down||left||right){ y=(up?-1:0)+(down?1:0); x=(left?-1:0)+(right?1:0); if(x&&y){x*=0.85;y*=0.85;} } return clampRoundedSquare(x,cfg.invertY?-y:y); }

function updateMarkers(idx){
    const dirs = [
        {x: 1, y: 0},
        {x: 0.95, y: 0.95},
        {x: 0, y: 1},
        {x: -0.95, y: 0.95},
        {x: -1, y: 0},
        {x: -0.95, y: -0.95},
        {x: 0, y: -1},
        {x: 0.95, y: -0.95}
    ];

    const radiusPct = 38;
    const n = 4;

    dirs.forEach((d,i)=>{
        const m = document.getElementById('marker'+i);
        const clamped = clampRoundedSquare(d.x, d.y, n);
        m.style.left = (50 + clamped.x * radiusPct) + '%';
        m.style.top  = (50 + clamped.y * radiusPct) + '%';
        m.classList.toggle('active', i === idx);
    });
}

/* Trail drawing */
let trail = [];
function resizeCanvas(){ canvas.width = stickWrapper.clientWidth; canvas.height = stickWrapper.clientHeight; }
resizeCanvas(); window.addEventListener('resize', resizeCanvas);

function drawTrail(x,y){
    const cx = canvas.width/2, cy = canvas.height/2, cr = Math.min(canvas.width, canvas.height)/2 - 10;
    if(typeof x!=='undefined' && typeof y!=='undefined'){ trail.push({x:x,y:y}); if(trail.length>cfg.trail) trail.shift(); }
    if(!trail.length || trail.length<2){ ctx.clearRect(0,0,canvas.width,canvas.height); return; }
    ctx.clearRect(0,0,canvas.width,canvas.height);
    const trailColor = (getComputedStyle(document.documentElement).getPropertyValue('--trail-color')).trim();
    const first = trail[0]; const entriesAreNormalized = Math.abs(first.x)<=1.01 && Math.abs(first.y)<=1.01;
    for(let i=1;i<trail.length;i++){
        const p0=trail[i-1],p1=trail[i],t=i/trail.length;
        const x0=entriesAreNormalized?cx+p0.x*cr:p0.x, y0=entriesAreNormalized?cy+p0.y*cr:p0.y;
        const x1=entriesAreNormalized?cx+p1.x*cr:p1.x, y1=entriesAreNormalized?cy+p1.y*cr:p1.y;
        if(!isFinite(x0)||!isFinite(y0)||!isFinite(x1)||!isFinite(y1)) continue;
        ctx.beginPath(); ctx.moveTo(x0,y0); ctx.lineTo(x1,y1);
        ctx.lineWidth = 10*(t*2); ctx.lineCap='round'; ctx.globalAlpha=1; ctx.strokeStyle=trailColor; ctx.stroke();
    }
    ctx.globalAlpha=1;
}

/* ======================
   Color panel (palette)
   ====================== */

const colors = [
	"#FFE5E5","#FFB3B3","#FF8080","#FF4D4D","#E60000","#B30000","#800000","#4D0000",
	"#FFF0E5","#FFD1B3","#FFB380","#FF944D","#FF6600","#CC5200","#993D00","#662900",
	"#FFFDE5","#FFF7B3","#FFF080","#FFEA4D","#FFD700","#CCAC00","#998200","#665700",
	"#F5FFE5","#E0FFB3","#CCFF80","#B8FF4D","#99FF00","#77CC00","#559900","#336600",
	"#E5FFE5","#B3FFB3","#80FF80","#4DFF4D","#00E600","#00B300","#008000","#004D00",
	"#E5FFF9","#B3FFF0","#80FFE6","#4DFFDB","#00E6CC","#00B3A0","#008073","#004D47",
	"#E5F9FF","#B3EDFF","#80E0FF","#4DD3FF","#00BFFF","#0099CC","#007399","#004D66",
	"#E5EFFF","#B3CCFF","#8099FF","#4D66FF","#0033FF","#0029CC","#001F99","#001466",
	"#F0E5FF","#D1B3FF","#B380FF","#944DFF","#6600FF","#5200CC","#3D0099","#290066",
	"#FFE5F7","#FFB3E6","#FF80D6","#FF4DC5","#FF00AA","#CC0088","#990066","#660044",
	"#FFFFFF","#E6E6E6","#CCCCCC","#999999","#666666","#333333","#1A1A1A","#000000",
	"#ffffff00"
];

const colorPanel = document.getElementById('colorPanel');
// Create mode toggle
const modeToggle = document.createElement("div"); modeToggle.className = 'modeToggle';
const bgBtn = document.createElement("button"); bgBtn.textContent = "BACKGROUND"; bgBtn.style.font = "inherit"; bgBtn.style.padding="4px"; bgBtn.style.border="none"; bgBtn.style.cursor="pointer"; bgBtn.style.background="#444"; bgBtn.style.color="#ddd";
const txtBtn = document.createElement("button"); txtBtn.textContent = "LABEL"; txtBtn.style.font = "inherit"; txtBtn.style.padding="4px"; txtBtn.style.border="none"; txtBtn.style.cursor="pointer"; txtBtn.style.background="#111"; txtBtn.style.color="#ddd";
modeToggle.appendChild(bgBtn); modeToggle.appendChild(txtBtn);
colorPanel.appendChild(modeToggle);

let colorMode = "background";
bgBtn.addEventListener("click", () => { colorMode = "background"; bgBtn.style.background="#444"; txtBtn.style.background="#111"; });
txtBtn.addEventListener("click", () => { colorMode = "text"; txtBtn.style.background="#555"; bgBtn.style.background="#333"; });

colors.forEach(c => {
  const swatch = document.createElement("div");
  swatch.className = "swatch";
  swatch.style.backgroundColor = c;
  swatch.addEventListener("click", () => {
    if (colorPanel.targetBtn) {
      const btnName = colorPanel.targetBtn.dataset.btn;
      if (colorMode === "background") {
        colorPanel.targetBtn.style.backgroundColor = c;
        updateColor(btnName, c, appState.buttons[btnName]?.color);
      } else {
        colorPanel.targetBtn.style.color = c;
        updateColor(btnName, appState.buttons[btnName]?.backgroundColor, c);
      }
    }
  });
  colorPanel.appendChild(swatch);
});

// open panel on right-click and also on left-click to select that's awaiting target
Object.values(btnEls).forEach(btn => {
  btn.addEventListener("contextmenu", e => {
    e.preventDefault();
    colorPanel.style.display = "flex";
    colorPanel.targetBtn = btn;
  });
  btn.addEventListener("click", e => {
    if (colorPanel.style.display === "flex") {
        colorPanel.targetBtn = btn;
        e.stopPropagation();
    }
  });
});

document.addEventListener("mousedown", e => {
  if (!colorPanel.contains(e.target) && e.button === 0) {
    colorPanel.style.display = "none";
    colorPanel.targetBtn = null;
  }
});

/* ======================
   Click to set target + close palette
   ====================== */

// bring color panel to bottom anchored
colorPanel.style.position = "fixed";
colorPanel.style.bottom = "0px";
colorPanel.style.left = "0px";
colorPanel.style.width = "100%";
colorPanel.style.padding = "10px";
colorPanel.style.zIndex = "1000";
colorPanel.style.display = "none";

/* ======================
   GAME ANIMATE LOOP
   ====================== */

function animate(){
    activeGamepadIndex = detectActiveGamepad();
    const pad = navigator.getGamepads()[activeGamepadIndex];
    updateButtons(pad);
    handleDpadMovement(pad);
    const {x,y}=getStickXY(pad);
    const cx=canvas.width/2, cy=canvas.height/2;
    const radius=canvas.width/2 - 25;
    const jx=cx+x*radius, jy=cy+y*radius;
    joystick.style.left=jx+'px';
    joystick.style.top=jy+'px';
    const deg=(Math.atan2(y,x)*180/Math.PI+360)%360;
    let idx=-1;
    if(Math.hypot(x,y)>0.5) idx=Math.round(deg/45)%8;
    updateMarkers(idx);
    // trail uses normalized values for drawTrail; keep previous behavior
    trail.push({x:jx,y:jy}); if(trail.length>cfg.trail) trail.shift();
    drawTrail();
    requestAnimationFrame(animate);
}
animate();

/* ======================
   Init & boot
   ====================== */

loadState(); // apply stored state

/* Attach initial saved styles back into state if not present (ensures appState contains everything) */
for (const key in btnEls) {
    if (!appState.buttons[key]) {
        const el = btnEls[key];
        const cs = window.getComputedStyle(el);
        appState.buttons[key] = {
            top: el.style.top || cs.top,
            left: el.style.left || cs.left,
            width: el.style.width || cs.width,
            height: el.style.height || cs.height,
            borderRadius: el.style.borderRadius || cs.borderRadius,
            fontSize: el.style.fontSize || cs.fontSize,
            display: el.style.display || cs.display,
            backgroundColor: el.style.backgroundColor || cs.backgroundColor,
            color: el.style.color || cs.color,
            label: (el.textContent||"").trim()
        };
    }
}
if (!appState.joystick || Object.keys(appState.joystick).length===0) {
    const cs = window.getComputedStyle(stickWrapper);
    appState.joystick = {
        top: stickWrapper.style.top || cs.top,
        left: stickWrapper.style.left || cs.left,
        width: stickWrapper.style.width || cs.width,
        height: stickWrapper.style.height || cs.height,
        borderRadius: stickWrapper.style.borderRadius || cs.borderRadius,
        display: stickWrapper.style.display || cs.display
    };
}
scheduleSave();

/* ================
   Profile hotkeys
   ================ */
document.addEventListener("keydown", e => {
    if (!e.ctrlKey && e.key.startsWith("F")) {
        const n = parseInt(e.key.slice(1));
        if (n >= 1 && n <= PROFILE_COUNT) loadProfile(n);
    }
    if (e.ctrlKey && e.key.startsWith("F")) {
        const n = parseInt(e.key.slice(1));
        if (n >= 1 && n <= PROFILE_COUNT) saveProfile(n);
    }
});

/* Expose some functions on window for convenience */
window.trailpad = {
    saveState: forceSave,
    scheduleSave,
    updatePosition,
    updateSize,
    updateLabel,
    updateColor,
    setHiddenButton,
    setJoystickHidden,
    saveProfile,
    loadProfile
};

</script>
</body>
</html>
